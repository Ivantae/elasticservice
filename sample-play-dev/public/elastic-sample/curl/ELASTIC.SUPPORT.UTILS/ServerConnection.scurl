{curl-file-attributes character-encoding = "utf8"}



{define-class public PlusHttpFormStringParam {inherits HttpFormStringParam }
  {constructor public {default ...}
    {construct-super {splice ...}}
  }

  {method public {request-data-urlencoded-string default-character-encoding:CharEncoding = CharEncoding.ascii}:String
    let str:String = {super.request-data-urlencoded-string default-character-encoding=default-character-encoding}
    {return str}
  }

  {method public {request-data-urlencoded-bytes default-character-encoding:CharEncoding = CharEncoding.ascii}:{Array-of byte}

    let str:{Array-of byte} = {{Array-of byte}} ||{super.request-data-urlencoded-bytes default-character-encoding=default-character-encoding}
    ||다시 인코딩
    {if self.name == "" then
        {str.clear}
        let out:ByteVec={ByteVec max-size={max 1000000, self.string-value.size * 2}} ||max-chars를 명시하지않으면 제대로 생성되지않는다.
        let (in-used:int, out-made:int) = {encode-characters self.string-value, out, default-character-encoding}
        {for i:int=0 below out-made do {str.append out[i]}}        
     else
        set str = {super.request-data-urlencoded-bytes default-character-encoding=default-character-encoding}
    }    
    
    {return str}
  }
  
}


{define-class public PlusHttpFormData {inherits HttpFormData}
  {constructor public {default ...}
    {construct-super {splice ...}}
  }

  ||환경공단에서 content-type 을바꿔야하는경우 오버라이딩한다.
||--  {getter public {content-type}:#String
||--    {return "text/plain;charset=UTF-8"}
||--  } 

}
 

{define-proc public {gp-async-post-method-normal
                        query-url:Url, 
                        request-method:HttpRequestMethod=HttpRequestMethod.post,
                        charset:CharEncoding = {get-character-encoding-by-name "utf8"},
                        mime-type:String = HttpFormData.urlencoded-mime-type, ||HttpFormData.multipart-mime-type, 
                        line-sepa:String="\u0008",
                        ing-proc:#{proc-type {count:int}:void} = null,
                        ... 
                    }:(lines:StringBuf, error?:bool, message:String)
    
    || row 갯수
    let row-count:int=0
    
    || 리턴되는 변수 선언
    let lines:StringBuf = {StringBuf}
    let error? : bool = false
    let message : String = ""
    
    || 서버관련 정보
    let script-loc:Url = query-url
    let http-file:HttpFile = {script-loc.instantiate-File} asa HttpFile
    let req:PlusHttpFormData = {PlusHttpFormData mime-type = mime-type, default-character-encoding=charset}

    let headers:HttpRequestHeaders = {HttpRequestHeaders}
||--    {headers.append "Accept", "application/xml, text/xml, */"}
||--    {headers.append "X-Requested-With", "XMLHttpRequest"}
||--||--    {headers.append "Referer", "http://192.168.1.143:7001/inair/QuickView.jsp?formname=Frame::Login.xfdl"}
||--    {headers.append "Referer", "http://www.inair.or.kr/inair/QuickView.jsp?formname=Frame::Login.xfdl"}    
||--    {headers.append "Accept-Language", "ko-KR"}    
||--||--||--    {headers.append "Content-Type", "text/plain;charset=UTF-8"} ||오버라이딩됨
||--    {headers.append "Accept-Encoding", "gzip, deflate"}
||--    {headers.append "User-Agent", "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; NP06)"}
||--    {headers.append "DNT", "1"}
||--||--    {headers.append "DNT", "1\nContent-Type: text/plain;charset=UTF-8"}
||--||--    {headers.append "Cookie", "JSESSIONID=2XH7SbvDT5G6NCywZqhZpc7t2mLMvyLqKpKBCQ1w0fqhgVpwLZ0r!248174166"}
||--||--    {headers.append "Cookie", "JSESSIONID=fJz2Sb6SytwLl5GW0v0CLtmKvcm4Dhrhn76ylSn7MN1pgDyPcVth!248174166"}
    

||--Referer: http://192.168.1.143:7001/inair/QuickView.jsp?formname=Frame::Login.xfdl
||--Accept-Language: ko-KR
||--Content-Type: text/plain;charset=UTF-8
||--Accept-Encoding: gzip, deflate
||--User-Agent: Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; NP06)
||--Host: 192.168.1.143:7001
||--DNT: 1
||--Cookie: JSESSIONID=2XH7SbvDT5G6NCywZqhZpc7t2mLMvyLqKpKBCQ1w0fqhgVpwLZ0r!248174166

||--    {headers.append "Cookie", "JSESSIONID=2XH7SbvDT5G6NCywZqhZpc7t2mLMvyLqKpKBCQ1w0fqhgVpwLZ0r!248174166"}
    
    || rest argument (...) 로 넘어오는 HttpFormParam 객체 처리
    {with-compiler-directives allow-implicit-any-casts? = true do
        {for param : HttpFormParam in ... do {req.append param}}
    }
    
    || 임시 변수 선언
    let wait?:bool=true                   || 루프
    let buf:StringBuf={StringBuf}         || 버퍼
    let web-stream:#HttpTextInputStream   || 연결 정보

    {dispatch-events false}
    || 1. 서버 연결하기

||--    let base-url:Url = {url "file:///d:/make-elastic.lock"}
||--||--    {try
||--        {with-local-file-lock base-url do ||[, timeout = time-value] [, old-lock-override-timeout = time-value] do

    ||{event-loop}
    
    {try
        set wait? = true
        let start:DateTime = {DateTime}
        
        {with-file-caching-style FileCachingStyle.reload do
            
            let afo:AsyncFileOpener = 
                {http-file.http-async-read-open 
                    character-encoding=charset, 
                    request-data = req,
                    request-headers = headers,
                    request-method = request-method,
                    always-return-response-headers? = true,
||--                    {on e:AsyncSocketEvent do ||사용불가
||--                        {dump e, {this-function}}
||--                    },
                    {on e:AsyncFileOpenEvent do
                        {dispatch-events false}

                        {if-non-null e.exception then
                            set error?=true
                            set message=e.exception.message asa String
                            
                            set wait?=false
                            
                         else
                            set web-stream = e.stream asa #HttpTextInputStream
                            set wait?=false
                        }                                
                    }||,
||--                    {on e:AsyncWorkEvent do
||--                        {dump e.exception, {this-function}}
||--                    }
                }

            || blocking
            {while wait? do
                {if {start.elapsed} >= 120s then
                    {throw {Exception "time out"}}
                    {break}
                }
                {dispatch-events false}
            }

            {if-non-null web-stream then
                let code:int = web-stream.response-headers.status ||200 == ok
                {if code != 200 then
                    set error? = true
                    set message = {String code}
                    set wait?=false
                    || 에러일 경우 stream 닫기
                    {web-stream.close}
                }
             else
                ||stream이 문제가 있는 경우
                ||set error? = true
                ||set message = {String code}
                set wait?=false                
            }
        }

||--        set error? = false
||--        set message = ""
||--                {dump "ok", base-url, {this-function}}
        
     catch e:HttpTooManyConnectionsException do
        set error? = true
        set message = e.message
        set wait?=false        
        {dump e.message, {this-function}}
        
     catch e:Exception do
        set error? = true
        set message = e.message
        set wait?=false
        {if web-stream != null and web-stream.open? then {web-stream.close}}
    }
    

    {dispatch-events false}

    set wait? = false
    {if not error? then
        set wait? = true
        {try            
            {web-stream.async-read-string ||buf=buf, append?=true, partial?=true,
                append?=false, partial?=true,
                {on e:AsyncStreamReadEvent do
                    ||{dump e.data}
                    {dispatch-events false}

                    {if-non-null e.exception then
                        set error?=true
                        set message=e.exception.message asa String
                        
                        set wait?=false
                        {web-stream.close}
                        
                     else
                        
||--                        {do
||--                            let count:{Array-of int} =  {gp-find-char-in e.data asa StringBuf, line-sepa[0]}                        
||--                            {inc row-count, count.size}
||--||--                            {dump (e.data asa StringBuf).size, count.size, row-count}
||--                            {if-non-null ing-proc then {ing-proc row-count}}
||--                        }

                        {buf.concat e.data asa StringBuf}
                        
                        {if e.done? then                                    
                            {web-stream.close}
                            set wait?=false
                        }
                    }
                    

                }
            }
            
         catch e:Exception do
            {if web-stream != null and web-stream.open? then {web-stream.close}}
            ||{if-non-null web-stream then {web-stream.close}}            
            set error?=true
            set message = e.message
            set wait?=false     
        }
    }

    || blocking
    {while wait? do {dispatch-events false}}

    ||확인차 한번더 닫아준다.
    {if web-stream != null and web-stream.open? then {web-stream.close}}
    
    || 2. 데이터 읽기
    {if not error? then            
    }

    
    {return buf, error?, message}
}



